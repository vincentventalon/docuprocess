/**
 * Sitemap Dates Module
 *
 * Provides accurate lastmod dates for sitemap generation:
 * - Static pages & MDX docs: read from pre-generated JSON (git dates)
 * - DB content (templates): updated_at from Supabase
 *
 * The JSON file is generated by scripts/generate-sitemap-dates.js
 * and committed to git. This avoids issues with Vercel's shallow clones.
 */

const fs = require("fs");
const path = require("path");

// Pre-generated dates from git history (created by scripts/generate-sitemap-dates.js)
const DATES_FILE = path.join(process.cwd(), "generated/sitemap-dates.json");

// Cache for static page dates (loaded once from JSON)
let staticDatesCache = null;

// Cache for template dates (fetched once from DB)
let templateDatesCache = null;

/**
 * Load static page dates from the pre-generated JSON file
 * @returns {Object} Map of URL path -> ISO date string
 */
function loadStaticDates() {
  if (staticDatesCache) {
    return staticDatesCache;
  }

  try {
    if (fs.existsSync(DATES_FILE)) {
      const content = fs.readFileSync(DATES_FILE, "utf-8");
      staticDatesCache = JSON.parse(content);
      console.log(`[sitemap-dates] Loaded ${Object.keys(staticDatesCache).length} dates from JSON`);
    } else {
      console.warn("[sitemap-dates] Dates file not found, using fallback dates");
      staticDatesCache = {};
    }
  } catch (error) {
    console.warn("[sitemap-dates] Failed to load dates file:", error.message);
    staticDatesCache = {};
  }

  return staticDatesCache;
}

/**
 * Fetch all template dates from the database
 * @returns {Promise<Map<string, string>>} Map of "category/slug" -> updated_at ISO string
 */
async function fetchTemplateDates() {
  if (templateDatesCache) {
    return templateDatesCache;
  }

  templateDatesCache = new Map();

  try {
    const { createClient } = await import("@supabase/supabase-js");

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

    if (!supabaseUrl || !supabaseKey) {
      console.warn("[sitemap-dates] Supabase credentials not available, templates will use fallback dates");
      return templateDatesCache;
    }

    const supabase = createClient(supabaseUrl, supabaseKey);

    const { data, error } = await supabase
      .from("example_templates")
      .select("slug, category, updated_at")
      .eq("is_active", true)
      .not("slug", "is", null)
      .not("category", "is", null);

    if (error) {
      console.warn("[sitemap-dates] Failed to fetch template dates:", error.message);
      return templateDatesCache;
    }

    for (const template of data || []) {
      if (template.slug && template.category && template.updated_at) {
        // Key is "category/slug" with underscores converted to hyphens
        const categorySlug = template.category.replace(/_/g, "-");
        const key = `${categorySlug}/${template.slug}`;
        templateDatesCache.set(key, template.updated_at);
      }
    }

    console.log(`[sitemap-dates] Loaded ${templateDatesCache.size} template dates from DB`);
  } catch (error) {
    console.warn("[sitemap-dates] Error fetching template dates:", error.message);
  }

  return templateDatesCache;
}

/**
 * Get the last modified date for a URL path
 * @param {string} urlPath - The URL path (e.g., "/pricing", "/docs/get-started", "/templates/invoice/my-template")
 * @returns {Promise<string|null>} ISO date string or null (fallback to build date)
 */
async function getLastModDate(urlPath) {
  // Template detail pages: /templates/{category}/{slug}
  const templateMatch = urlPath.match(/^\/templates\/([^/]+)\/([^/]+)$/);
  if (templateMatch) {
    const category = templateMatch[1];
    const slug = templateMatch[2];
    const key = `${category}/${slug}`;
    const templateDates = await fetchTemplateDates();
    const updatedAt = templateDates.get(key);
    if (updatedAt) {
      return new Date(updatedAt).toISOString();
    }
    return null;
  }

  // Static pages and MDX docs - read from pre-generated JSON
  const staticDates = loadStaticDates();
  return staticDates[urlPath] || null;
}

/**
 * Initialize caches (call at the start of sitemap generation)
 */
async function initializeCaches() {
  loadStaticDates();
  await fetchTemplateDates();
}

/**
 * Clear all caches (useful for testing)
 */
function clearCaches() {
  staticDatesCache = null;
  templateDatesCache = null;
}

module.exports = {
  getLastModDate,
  initializeCaches,
  clearCaches,
  loadStaticDates,
  fetchTemplateDates,
};
